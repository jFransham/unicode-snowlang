,>,<[->->+>[>+<-]+>[<->-]<<<<]>>+>[<-<+>>-]<<[-<+>>>[>+<-]+>[<->-]<<<]>>[<<<+>>>-]<<<[-->>.++<<]
A B C D E
[>>>>>>,>>>++<<<<<<<<<,>>++>>>>[->+<<<<<<<->>>>>>]<<<<<<[->+>-[>+>>]>[+[-<+>]>+>>]<<<<<<]>>>[->+<]>>>>[->+>-[>+>>]>[+[-<+>]>+>>]<<<<<<]>+>>[-<<->>]<<<<<<[>>>>.++<<<<-]]
[,>,<[A->B->C+>D[>+<-]+>[<->-]<<<<]>>>D[>+<-]+>[<->-]<[-<C+>]<<B[-<+>>>[>+<-]+>[<->-]<<<]>>D[<<B+>>-]<<[--<<.++>>]]
[
	$6 = (read)
	$0 = (read)
	$2 = 2 -- divisor for $0
	$9 = 2 -- divisor for $6
	while $6 != 0:
		$6--
		$7++
		$0--
	-- ^ this calculates $0 -= $6, duplicating $6 in $7
	[$1, $2, $3, $4] = [$0, $2 - ($0 % $2), $0 % $2, $0 / $2]
	[$8, $9, $10, $11] = [$7, $9 - ($7 % $9), $7 % $9, $7 / $9]
	-- ^ description of this exact process [here](http://stackoverflow.com/questions/27905818/divmod-algorithm-in-brainfuck)
	--   (no need to duplicate that description)
	$8++
	while $10 != 0:
		$10--
		$8--
	-- ^ this basically calculates $8 += if $10 == 0 then 1 else 0
	$1++
	-- this is to count inclusively, rather than exclusively
	while $4 != 0:
		(echo $8)
		$8 += 2
		$4--
]

[->+>-[>+>>]>[+[-<+>]>+>>]<<<<<<]
[
$0 = A
$2 = B
while $0 != 0:
	$0--
	$1++
	$2--
	if $2 != 0:
		$3++
	else if $3 != 0:
		$3++
		while $3 != 0:
			$3--
			$2++
		
]
[
$0 >= 0;
$2 > 0;
$1 = 0;
$[3..] = 0;
]

$(a + expr)
